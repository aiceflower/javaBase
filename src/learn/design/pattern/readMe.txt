一、单例模式
 包：package learn.design.pattern.singleton
 单例分为两种，饿汉式和懒汉式
  	饿汉式，类一加载就创建对象，特点是：加载速度慢，运行速度快，线程安全
 	懒汉式，对象应用的时候才创建对象，特点是：加载速度快，但运行速度快，线程不安全
 	懒汉式线程安全解决方案：使用双重判断加上锁来解决
二、模板方法设计模式
	包：learn.design.pattern.templatemethod
	组成：抽象基类、具体子类
	抽象基类：
		提供基本方法（非抽象方法）：子类的共性方法;
		抽象方法：知道原则，但不知道具体实现细节，让子类去实现;
		可选的钩子函数：只在基类中提供，默认实现或空实现，让子类去决定是否挂载，及如何挂载
		模板方法（申明为final，不让子类复写）：封装了所有子类共同遵循的算法框架
		申明为final的原则，好莱坞原则：子类可以改变父类中的可变逻辑，但不能改变整体逻辑结构（明星与公司）
	具体子类：
		实现基类中的抽象方法
		可选的去覆盖钩子方法
	总结：准备一个抽象类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法交由子类实现，
		用钩子方法给予子类更大的灵活性。最后将方法汇总构成一个不可改变的模板方法。
	使用场景：
		1.算法或操作遵循相似的逻辑 
		2.重构时（把相同的代码抽取到父类中）
		3.重要、复杂的算法、核心算法设计为模板算法
	优点：封装性好、利用性好、屏蔽细节、便于维护
	缺点：继承（单继承）
三、适配器模式
	包：learn.design.pattern.adapter
	把不兼容的转换为兼容的都是适配器
	分类：组合、继承
	组合：
		把“被适配者”作为一个对象组合到适配器类中，以修改目标接口包装被适配者。
	继承：（只能适配单一个某个类）
		通过多重继承不兼容接口，实现对目标接口的匹配，单一的为某一个类而实现适配。
	作用：
		1.透明
			通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。
		2.重用
			复用了现存的类，解决了现存类和复用环境要求不一致的问题。
		3.低耦合
			将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码（遵循开闭原则）
四、工厂模式
	包：
		learn.design.pattern.factory(工厂方法模式)
		learn.design.pattern.abstractfactory(抽象工厂模式)
	概念：
		实例化对象，用工厂模式代替new操作
		工厂模式包括工厂方法模式和抽象工厂模式
		抽象工厂模式是工厂方法模式的扩展
	意图：
		定义一个接口来创建对象，但是让子类来决定哪些类需要被实例化
		工厂方法把实例化的工作推迟到了子类中去实现
	应用场景：
		有一级类似的对象需要创建
		在编码时不能预见需要创建哪种类的实例
		系统需要考虑扩展性不应依赖于产品类实例如何被创建，组合和表达的细节
	动机：
		改变某个对象，希望依赖于他的对象不随之发生变化，低耦合
	设计：
		1.尽量松耦合，一个对象的依赖对象的变化与本身无关
		2.具体产品与客户端剥离，责任分割
	对比：
		工厂模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广
		工厂模式用来创建一个产品的等级结构，而抽象工厂模式多用来创建多个产品的等级结构
		工厂模式（头发）只有一个抽象产品类，而抽象工厂模式有多个抽象产品类（圣诞系列，新年系列）
	帮助我们：
		在不修改具体工厂角色的情况下引进亲的产品
		不关心对象如何创建，明确了职责
		面向接口编程，而不要面向实现编程
	tips:工厂方法的实质不在于它的参数，而在于它的返回结果，从行为上返回了一个抽象的对象，而非一个具体的对象，参数的个数跟业务逻辑是相关的，根据业务逻辑传参
五、策略模式
	包：
		learn.design.pattern.strategy
	什么是策略模式:
		抽象出不变的部分（支付算法）
		定义算法族分别封装起来（工商支付，支付宝支付，微信支付等）
		客户端不会受算法改变的影响
		对新增需求提供弹性的支持（增加一个qq支付）
		官方定义：
			策略模式将可变的部分从程序中分离成算法接口，在该接口下分别封装一系列算法实现
	设计原则：
		1.找出应用中需要变化的部分，将不变的东西抽象为接口，将变化的部分交给实现去做
		     具体体现：鸭子的飞行行为千变万化，但鸭子具有飞行行为本身是不变的，将行为抽象为策略接口，变化的部分让子类去实现
		2.面向接口编程，而不是面向实现编程
		     具体体现：鸭子拥有一个飞行策略接口，而不是具体的实现
		3.多用组合，少用继承
	实现步骤：
		1.通过分离变化得出策略接口strategy
		2.strategy的实现类
		3.客户程序中“有一个”strategy
		4.在客户程序中选择/组装正确的strategy实现
	优点：
		1.使用了组合，使架构设计更加灵活
		2.富有弹性，可以较好的应对变化（开――闭原则）
		3.更好的代码复用性（相对于继承）
		4.消除大量的条件语句
	缺点：
		1.客户代码需要了解每个策略实现的细节
		2.增加了对象的数目
	适用场景：
		1.许多相关的类仅仅是行为差异
		2.运行时选取不同的算法谈何
		3.通过条件语句在多个分支中选取一个
六、观察者模式（又被称为：发布订阅模式）
	包：learn.design.pattern.observer
	定义：
		定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
	从六个方法认识观察者模式：
		1.目标与观察者之间的关系
			a)多个观察者对应一个目标 [天气(sbject)]-->[女朋友，老妈(observer)]定义一个update方法
			b)一个观察者对应多个目标 [天气，报纸(sbject)]-->[女朋友(observer)]定义多个update方法
		2.单向依赖
			只有观察者依赖目标，没有目标依赖观察者
		3.命名建议
			目标接口：建议在名称后面跟Subject
			观察者接口：建议在名称后面跟Observer
			观察者接口的更新方法:建议名称为update
		4.触发通知的时机
			完成状态维护后通知
		5.观察者模式的调用顺序的示意图
			准备阶段：
				1.创建目标对象
				2.创建观察者对象
				3.向目标对象注册观察者对象
			运行阶段：
				1.改变目标对象状态
				2.通知所有注册的观察者对象进行相应处理
				3.回调目标对象，获取相应的数据
		6.通知的顺序
			观察者实现的顺序不能依赖于通知的顺序，多个观察者的顺序是平行的，相互之间不能有依赖关系
	观察者模式实现的两种方式：
		推模型：
			目标对象主动向观察者推送目标的详细信息
			推送的信息通常是目标对象的全部或部分数据
		拉模型：
			目标对象在通知观察者的时候，只传递少量的信息。
			如果观察者需要更多的信息，由观察者主支到目标对象中获取，相当于是观察者从目标对象中拉数据
			一般这种模型的实现中会把目标对象自身通过update方法传递给观察者
		两种类型的比较：
			推：假定目标对象知道观察者需要的数据（会使观察者对象难以复用）
			拉：目标对象不知道观察者具体需要什么数据，因此把自身传给观察者，同观察者来取值（传了对象本身，可按需获取）
	观察者模式通用代码：
		步骤：
			1.目标对象的定义
			2.具体目标对象的定义
			3.观察者的接口定义
			4.观察者的具体实现
	观察者的优缺点：
	  优：
		观察者模式实现了观察者和目标之间的抽象耦合
		观察者模式实现了动态联动
		观察者模式支持广播通信
	  缺：
	  	可能会引起无谓的操作（比如只想给某一个观察者推送内容，却忘记删除其它的观察者）
	适用场景：
		当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化
		如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟该有多少对象需要被连带改变
		当一个对象必需通知其他的对象的，但是你双希望这个对象和其它被它通知的对象是松散耦合的。
		
	高级观察者模式：
		可将不同的内容发送给不同的观察者。将notifyObservers方法申明为抽象的让子类去实现
		例：黄明的女朋友只需要在下雨的时候提醒，黄明的老妈则需要在下雨跟下雪的时候提醒，自己实现
七、代理模式
	包：
	概念：
		为其它对象提供一种代理，以控制对这个对象的访问
		代理对象起到中介的作用，可去掉功能服务或增加功能服务
	常见的代理模式：
		远程代理（监控分店的运营情况）
		虚拟代理（如图片未加载完可用其它小图片代理显示，等图片加载完成后再显示原图片）
		保护代理（控制权限，未登陆只能看贴，登陆后可以发贴）
		智能引用代理（火车票代售点的代理）
	两种实现方式：静态代理，动态代理
		静态代理：代理和被代理的对象在代理之前是确定的。他们都实现相同的接口或者继承相同的抽象类
		动态代理：
			实现步骤：
				1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法
				2.创建被代理的类以及接口
				3.调用Proxy的静态方法,创建一个代理类
				Proxy.newProxyInstance(ClassLoader loader, Class[] interface, InvocationHandler h);
				4.通过代理调用方法
八、责任链模式
	包：
	在责任链模式中，作为请求接收者的多个对象通过对其后继的引用而连接起来形成一条链。请求在这条链上传递，直到链上某一个接收者处理这个请求。
	每个接收者都可以选择自行处理或是向后继传递请求。
	tips：客户不管最终是谁(销售、管理者、销售总监...)处理了我的请求，我只要一个结果(我要的折扣)就可以了。
	缺点：
		1.在链中传递，会损耗时间（时间）
		2.创建了大部分的处理器对象，但仅仅使用了少部分，大部分只是个过客（内存）
	应用：
		1.异常处理机制：
			方法的调用自然而然的构成了一个栈，当栈顶产生异常时，就需要将这个异常抛出，被抛出的异常就沿者栈向下发展去寻找一个处理的块,
			这个时候栈顶方法抛出的异常就是一个请求，调用栈上的每一级方法就相当于一个handler（可选择自行处理异常，或向下一栈传递下去）
			异常是一个请求，调用栈中的每一级作为一个Handler存在。整个handler就构成了一个责任链。
		2.http请求(但是FilterChain不是一个纯的责任链[COR],在这个链中同时可以有多个对象处理请求【在“今天”讲的中只有一个链可以处理请求】)
			请求，request
			handler，filter()
			传递，doFilter();
九九、其它
	1.当业务变更我们希望新增一个类，而非修改原有的代码。
	